1. 两个分数a/b 和 c/d   他们的最小公倍数应该一个是一个分数（x/y），则x是a,c的最小公倍数，b,d的最小公约数为x,即x一定会被b,d整除。
(x/y)/(a/b) = xb/ya;  
2.Given a positive integer N, you should output the leftmost digit of N^N.
m=n^n;  
linag两边同时log10  
log10(m)=log10(n^n)=n*log10(n);  
所以，m=10^(n*log10(n));  
m的最左边一位由n*log10(n)的小数部分决定。m=10^((n*log10(n))的整数部分)+10^((n*log10(n))的小数数部分);10的整数次方肯定是1000……，最左边一位由10^((n*log10(n))的整数部分)决定。  
3.一次生日Party可能有p人或者q人参加,现准备有一个大蛋糕.问最少要将蛋糕切成多少块(每块大小不一定相等),才能使p人或者q人出席的任何一种情况,都能平均将蛋糕分食.
将蛋糕切成大小分别为1/3,1/3,1/6,1/6的四块即满足要求.  
当2个人来时，每人可以吃1/3+1/6=1/2 , 1/2块。  
当3个人来时，每人可以吃1/6+1/6=1/3 , 1/3, 1/3块。  
如果能平均地分为p份或q份，我们可以先分为d(最大公约数)=gcd(p,q)份,因为当分为d份的时候,  
你可能选择再把每份分为p/d份(也就是把整体分为p份),也可以选择将每份分为q/d份(也就是把整体分为q份),  
这两种选择里,肯定不会有切到相同位置的一刀!所以我们可以得到公式:s=p+q-gcd(p,q);  
int gcd(int a, int b) {  
    return b == 0 ? a : gcd(b, a%b);  
}  
int lcm(int a, int b) {  
    return a / gcd(a, b) * b;  
}  
4.假设：
S1 = 1
S2 = 12
S3 = 123
S4 = 1234
.........
S9 = 123456789
S10 = 1234567891
S11 = 12345678912
............
S18 = 123456789123456789
..................
现在我们把所有的串连接起来
S = 1121231234.......123456789123456789112345678912.........
那么你能告诉我在S串中的第N个数字是多少吗？
int t = 1;  
/// 先确定n是第几个数  
while (n > t) {  
    n -= t;  
    t++;  
}  
n %= 9;  
if (n == 0) n = 9;  
cout << n << endl;  

5.题意：给你n,k,m，问n经过几次操作后%k会等于初始(n+1)%k，操作可以是对m做+-*%
思路：显然的搜索题，直接BFS，不过问题在于我们不能步步对k取模，因为如果过程有%m%k结果不会跟总结果%k相等
我们每步都对m*k取模，然后最后对k取模即可。正确性显然。
You should know that if a = b * q + r (q > 0 and 0 <= r < q), then we have a % q = r.
取模的结果>=0，也就是不会出来负数，得到的是取模后最小的整数
ll mod(ll a,ll b) {  
    return (a % b + b) % b;  
}  